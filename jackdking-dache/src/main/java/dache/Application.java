package dache;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableAsync;

/**
 * Hello world!
 * 北京市界的地理坐标为：北纬39°28’至41°03’,东经115°25’至117°35’
 * 1. 根据北京的经纬度区间，设置北京这边的服务的边界。
 * 2. 制定经纬度网络，设定网格的单位长度，每个网格点作为乘客行程单的队列数据。
 * 		赤道长40000km，在赤道上东西、南北方向每秒角度对应于30.86m。
		4*10^7m/(360*60*60)=30.86m/sec。
 * 
 * 3. 设置每个网格点的经纬度差距值为： 40''为网格点之间的距离，大约1200m。
 * 
 * 4. 用户的请求会根据请求的经纬度值分发到最近的网格节点中。每个网格节点都会以自己为中心，在节点周围画四个20''的正方形区域，区域内的请求都进入这个节点队列。
 * 
 * 5. 司机抢单也是按照同样的规则来抢单，优先在最近的节点队列抢单，没抢到，则轮询周边的四个队列。
 * 
 * 
 * 	打车系统设计方案

	角色：司机，乘客
	
	业务： 乘客发布行程 、 司机抢单 
	
	数据结构： 行程队列-先进先出 ，司机抢单请求对队列中的行程数据，抢单成功后乘客和司机互联完成后续业务。
	
	数据设计方案：
	
	1. 打车是城市服务，基于城市，因此会有一份城市 经纬度范围数据作为基础数据。
	2. 对城市进行经纬度层的网格建模，得到一组城市定量的经纬度节点信息。
	3. 乘客发出的订单请求包括gps定位的经纬度数据。乘客行程数据进入最近的城市经纬度节点（队列）。
	4. 司机发出的抢单请求也有经纬度数据，将请求发到附近的经纬度节点队里中去抢用户行程数据。
	
	要求：
	1. 经纬度内的所有乘客，都能够发布自己的行程单，但不一定能被司机接收到。如果附近一辆车都没有，那就可能会一直等待。
	2. 司机发出的抢单请求，包括自己的经纬度数据，还会有车的速度跟方向。(当前版本不考虑车行驶状态。)
	3. 如果用户在行程单网格点等了很久了，可用为用户行程单推到附近活跃的网格点中。（考虑跨网格步长 不要太多，否则司机和乘客距离太远）
	4. 保证同一个形成单不被重复抢到。通过形成单唯一性，保证订单唯一性，订单被接后，如何保证订单不被其他司机抢到？
	5. 两种方案对比：
			第一种：将行程单放到不同的网格点，但是行程单抢到后不好维护删除掉。
			第二种：行程单只在一个网格点里面，司机的抢单请求可以发到周围附近的网格进行轮询抢单。这样方式对于行程单数据特别好维护，不存在行程单脏数据。
	
	问题：
	1. 乘客发布行程单后，又取消行程单，需要将对应网格点的队列中的行程单数据清除掉。
	2. 司机接到行程单后，又取消了，需要将行程单放回原来的网格点队列中去。
	
	注意：
	1. 系统接单后，打印出司机和行程单信息。
	
 */
@EnableAsync
@SpringBootApplication
public class Application
{
    public static void main( String[] args )
    {

        SpringApplication.run(Application.class, args);
    }
}
